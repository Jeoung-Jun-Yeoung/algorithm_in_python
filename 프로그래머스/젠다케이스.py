def solution(s):
    answer = ''
    # 스플릿시에 문제점은 공백이 몇개인지 체크가 안된다.
    # 이걸 수동으로 미리 체크하니까 시간초과가 뜬다.
    # 한번에 변환해야한다.
    # 쭉 답에 더해가면서 그냥 내가 바꿔주는방법으로 가보자
    # 처음은 그냥 시작하고 공백을 만나면 flag를 걸어줌.
    # flag 조건이면서 문자를 만나면 U로 변환.
    # flag 트루이면서 문자를 만나면 대문자로 변환
    flag = False
    first = False
    if s[0].isalpha():
        first = True

    for ch in s:
        if ch == " ":
            flag = True
            answer += " "
        if ch.isdigit() and not flag:
            answer += ch
        elif not flag and not first:
            answer += ch.lower()
        elif flag and ch != " ":
            answer += ch.upper()
            flag = False
        if first:
            answer += ch.upper()
            first = False

    print(answer)

    return answer


# 리뷰 :
# 문자열 다루는 문제를 공부하는데 좋았던것 같다.
# 문자열 함수를 잘 쓰면 쉬운 문제라고 생각함. 근데 굳이 몰라도 될것 같긴하다.

# 첫번째 풀이
# : 공백기준으로 스플릿을 한다. 덩어리들을 보면서 첫글자가 숫자면 냅두고, 문자면 title함수로 한번에 바꿔줌
# 이후에 덩어리를 공백더해가며 붙여주었다.
# 그런데 case한개에서 오류가 떴다. 문제를 다시 읽어보니까 공백이 연속해서 나올수 있었다.
# 그래서 시작전에 공백개수를 세서 저장해둿다가 공백을 붙여야 할때 개수만큼 붙여주었다.
# 그러니까 시간초과가 발생

# 두번째 풀이
# 두번째 풀이는 문자열을 그냥 첨부터 보면서 바로바로 더해주기로 생각함
# 그래서 숫자면 무시하고 더한다.
# 문자면 2가지 선택지가 발생한다.
# 1 : 공백다음만난 첫번째 문자인가? -> 이러면 대문자로 변환후 저장
# 2 : 문자다음 나온 문자인가? -> 그냥 더함
# 이후 공백은 만나면 더해주었다. 이래서 공백을 더해주니까 따로 숫자를 셀 필요가 없었다.
# 그리고 공백을 만난것을 flag로 표현해주었다.
# 이후에 돌렸는데 문제가 첫번쨰 문자는 예외처리를 해주어야했다.
# 공백 기준조건에서 변환을 못해주었기때문.

# 한 40분정도 걸린것 같다. 문제 설계를 잘 해보자
